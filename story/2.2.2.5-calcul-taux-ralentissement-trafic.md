# Story 2.2.2.5 : Calcul taux de ralentissement de trafic (congestion dynamique)

**Status:** Draft  
**Epic:** Epic 2 - Système de Simulation et Prédiction  
**Story Number:** 2.2.2.5

---

## Story

**As a** système de simulation,  
**I want** calculer le taux de ralentissement de trafic (congestion) pour chaque microzone et chaque jour en combinant congestion statique (pré-calculée) et effets dynamiques (accidents, incendies, agressions, événements graves),  
**so that** le calcul Golden Hour (Story 2.2.3) peut utiliser ces données de congestion pour déterminer les temps de trajet réels.

---

## Acceptance Criteria

1. **Chargement congestion statique** : Chargement de la **congestion statique de base** depuis `data/source_data/congestion_statique.pkl` (pré-calculée Epic 1, Story 1.3). Cette table contient les facteurs statiques (saisonnalité, caractéristiques microzone).
2. **Table de congestion dynamique** : Création d'une structure de données (DataFrame ou dictionnaire) stockant le **taux de ralentissement** (facteur de congestion) pour chaque microzone et chaque jour de simulation, combinant congestion statique + effets dynamiques.
3. **Calcul du taux de ralentissement** : Le taux est calculé à partir de :
   - **Congestion statique de base** (pré-calculée, chargée depuis `data/source_data/`)
   - **Randomness** (variabilité aléatoire de base) avec **pondération dynamique** :
     - **Normalement** : randomité = **0.2 sur 1** (20% du score total de congestion)
     - **Événement important** : randomité = **0.7 sur 1** (70% du score total - événements majeurs augmentent l'imprévisibilité)
   - **Saisonnalité** : Déjà intégrée dans congestion statique (pré-calculée Story 1.3)
   - **Accidents** (↑ congestion : accidents augmentent le ralentissement)
   - **Incendies** (effets temporels) :
     - **Jour J** : ↑ congestion (augmentation ralentissement le jour de l'incendie)
     - **Jours J+1 et J+2** : ↓ congestion (diminution ralentissement - état de choc de la population, moins de circulation)
   - **Agressions graves** (effets temporels) :
     - **Jour J** : ↑↑ congestion (augmentation **forte** du ralentissement - diminution très forte de la circulation)
     - **Jours J+1, J+2, J+3** : ↓ congestion (diminution ralentissement - augmentation de la circulation)
   - **Récurrence microzone** : Historique de la microzone (effets persistants)
   - **Voisins** : Influence des microzones adjacentes (propagation spatiale)
   - **Événements graves** : **Modification en temps réel** de la congestion du jour (Story 2.2.7). Les événements graves peuvent modifier la congestion immédiatement pour que le calcul Golden Hour (Story 2.2.3) utilise la nouvelle congestion.
   - **Événements positifs** : Effets sur la congestion (modulation)
   - **Congestion nuit** : Pour incidents s'étant produit la nuit, carte de congestion beaucoup plus faible :
     - **En moyenne divisée par 3** (avec effet aléatoire)
     - **Seulement 2.2 l'été** (divisée par 2.2 au lieu de 3)
     - Congestion nuit appliquée uniquement pour incidents nocturnes
4. **Formule de calcul** : `congestion_finale = congestion_statique × facteurs_dynamiques` où facteurs_dynamiques incluent accidents, incendies, agressions, événements graves (modifications temps réel).
5. **Modification temps réel** : Les événements graves (Story 2.2.7) peuvent modifier la congestion du jour **en temps réel** avant le calcul Golden Hour (Story 2.2.3).
6. **Sauvegarde** : Table sauvegardée en pickle (format standardisé) dans `data/intermediate/run_XXX/generation/congestion.pkl`.
7. **Intégration** : La table est **calculée jour-à-jour** **après** les vecteurs (Story 2.2.1) et **avant** le calcul Golden Hour (Story 2.2.3). **Ordre** : Vecteurs → Congestion (avec événements graves) → Golden Hour.
6. **Tests unitaires** : Validation calcul taux (plages raisonnables, cohérence avec accidents/incendies/agressions), validation effets temporels (incendies J/J+1/J+2, agressions graves J/J+1/J+2/J+3), validation saisonnalité (intersaison > hiver/été), validation pondération randomité (0.2 normal, 0.7 événement important), structure table, sauvegarde/chargement.

---

## Integration Verification

IV1: Table de congestion calculée correctement (facteurs cohérents avec accidents ↑, incendies avec effets temporels J↑/J+1↓/J+2↓, agressions graves avec effets temporels J↑↑/J+1↓/J+2↓/J+3↓, saisonnalité intersaison > hiver/été, pondération randomité 0.2/0.7).  
IV2: Table disponible et chargée avant Story 2.2.3 (Golden Hour).  
IV3: Performance : Calcul congestion n'impacte pas significativement le temps de génération jour-à-jour (≤ 0.33s/jour global).

---

## Tasks / Subtasks

- [x] Implémenter chargement congestion statique depuis `data/source_data/congestion_statique.pkl` (Story 1.3)
- [x] Définir structure de données pour table congestion dynamique (DataFrame ou dict)
- [x] Implémenter calcul taux de ralentissement base (randomness + congestion statique) avec pondération dynamique :
  - [x] Randomité normale : 0.2 sur 1 (20% du score total)
  - [x] Randomité événement important : 0.7 sur 1 (70% du score total)
- [x] Implémenter effet saisonnalité (intersaison > hiver/été)
- [x] Implémenter détection événements importants (pour basculer randomité 0.2 → 0.7)
- [x] Implémenter effet accidents sur congestion (↑)
- [x] Implémenter effet incendies avec effets temporels :
  - [x] Jour J : ↑ congestion (augmentation ralentissement)
  - [x] Jours J+1 et J+2 : ↓ congestion (diminution - état de choc population)
- [x] Implémenter effet agressions graves avec effets temporels :
  - [x] Jour J : ↑↑ congestion (augmentation forte - diminution très forte circulation)
  - [x] Jours J+1, J+2, J+3 : ↓ congestion (diminution - augmentation circulation)
- [x] Implémenter suivi historique incidents (pour appliquer effets temporels jours suivants)
- [x] Implémenter récurrence microzone (historique)
- [x] Implémenter influence voisins (propagation spatiale)
- [x] Implémenter effets événements (graves/positifs)
- [x] Implémenter congestion nuit pour incidents nocturnes :
  - [x] Congestion divisée par 3 en moyenne (avec effet aléatoire)
  - [x] Congestion divisée par 2.2 l'été (au lieu de 3)
  - [x] Application uniquement pour incidents s'étant produit la nuit
- [x] Implémenter formule agrégation (facteur multiplicatif final)
- [x] Intégrer calcul dans boucle jour-à-jour (avec Story 2.2.1)
- [x] Implémenter sauvegarde table congestion (pickle, format standardisé)
- [x] Tests : validation calcul taux (plages, cohérence)
- [x] Tests : validation effets temporels (incendies J/J+1/J+2, agressions graves J/J+1/J+2/J+3)
- [x] Tests : validation saisonnalité (intersaison > hiver/été)
- [x] Tests : validation pondération randomité (0.2 normal, 0.7 événement important)
- [x] Tests : validation congestion nuit (divisée par 3 moyenne, 2.2 l'été)
- [x] Tests : structure table, sauvegarde/chargement

---

## Dev Notes

### Architecture Context

- **Congestion statique** : Pré-calculée Epic 1, Story 1.3 (facteurs statiques : saisonnalité, caractéristiques microzone)
- **Congestion dynamique** : Calculée jour-à-jour en combinant congestion statique + effets dynamiques (accidents, incendies, agressions, événements)
- **Modification temps réel** : Les événements graves (Story 2.2.7) modifient la congestion du jour **en temps réel** avant Golden Hour
- **Utilisation** : Utilisé dans Story 2.2.3 (Golden Hour) pour calculer `temps_trajet_reel = temps_base × ∏(congestion_microzone_traversee)`
- **Calcul** : Jour-à-jour, **après** les vecteurs (Story 2.2.1) et **avant** Golden Hour (Story 2.2.3)
- **Ordre** : Vecteurs → Congestion (avec événements graves) → Golden Hour
- **Facteurs d'influence** :
  - **Randomness** (variabilité aléatoire) avec **pondération dynamique** :
    - Normalement : **0.2 sur 1** (20% du score total)
    - Événement important : **0.7 sur 1** (70% du score total - événements majeurs augmentent l'imprévisibilité)
  - **Saisonnalité** : Congestion plus forte en **intersaison** (printemps/automne) qu'en **hiver** et **été**
  - Accidents (↑ congestion)
  - **Incendies** (effets temporels) :
    - Jour J : ↑ congestion (augmentation ralentissement)
    - Jours J+1 et J+2 : ↓ congestion (diminution - état de choc de la population, moins de circulation)
  - **Agressions graves** (effets temporels) :
    - Jour J : ↑↑ congestion (augmentation **forte** - diminution très forte de la circulation)
    - Jours J+1, J+2, J+3 : ↓ congestion (diminution - augmentation de la circulation)
  - Récurrence microzone (historique)
  - Voisins (propagation spatiale)
  - Événements (graves/positifs)
  - **Congestion nuit** : Pour incidents nocturnes, congestion divisée par 3 (moyenne, effet aléatoire) ou 2.2 l'été
- **Suivi historique** : Nécessaire pour appliquer les effets temporels (incendies J+1/J+2, agressions graves J+1/J+2/J+3)
- **Ordre** : Calculé **avant** Story 2.2.3 (Golden Hour) mais **pendant** la génération jour-à-jour (Story 2.2.1)

### Source Tree

```
src/core/generation/
├── vector_generator.py
├── regime_manager.py
├── intensity_calculator.py
└── congestion_calculator.py  # Calcul congestion dynamique

data/source_data/
└── congestion_statique.pkl   # Congestion statique pré-calculée (Epic 1, Story 1.3)

data/intermediate/
└── run_XXX/
    └── generation/
        ├── vecteurs_base.pkl
        ├── vecteurs_proportions.pkl
        └── congestion.pkl  # Table taux de ralentissement (format standardisé)
```

### Dependencies

- **Congestion statique** : Epic 1, Story 1.3 (pré-calculée)
- Vecteurs : Story 2.2.1 (pour connaître accidents/incendies/agressions)
- Événements graves : Story 2.2.7 (modification temps réel congestion)
- Voisins : Données adjacents (en dur dans code)

### Implémentation des effets temporels

**Suivi historique nécessaire** : Pour appliquer les effets temporels aux jours suivants, il faut maintenir un historique des incidents par microzone :
- **Incendies** : Stocker les jours où des incendies (moyen/grave) ont eu lieu pour appliquer ↓ congestion aux jours J+1 et J+2
- **Agressions graves** : Stocker les jours où des agressions graves ont eu lieu pour appliquer ↓ congestion aux jours J+1, J+2 et J+3

**Exemple d'implémentation** :
```python
# Jour J : Incendie détecté
if incendie_moyen_grave_jour_j:
    congestion[j] *= 1.2  # ↑ congestion jour J
    historique_incendies[microzone].append(j)  # Enregistrer pour J+1 et J+2

# Jours suivants : Appliquer effets retardés
for jour_incendie in historique_incendies[microzone]:
    if j == jour_incendie + 1 or j == jour_incendie + 2:
        congestion[j] *= 0.8  # ↓ congestion (état de choc)
```

**Même logique pour agressions graves** avec fenêtre J+1, J+2, J+3.

### Implémentation saisonnalité et pondération randomité

**Saisonnalité** : La congestion est modulée selon la saison :
```python
# Déterminer saison à partir du jour de l'année
saison = determine_saison(jour_annee)

if saison in ['printemps', 'automne']:  # Intersaison
    facteur_saison = 1.2  # +20% congestion
elif saison in ['hiver', 'ete']:
    facteur_saison = 0.9  # -10% congestion
else:
    facteur_saison = 1.0  # Normal

congestion[j] *= facteur_saison
```

**Pondération randomité** : Le poids de la randomité dans le score total varie selon la présence d'événements importants :
```python
# Détecter événements importants (incendies graves, accidents majeurs, agressions graves)
evenement_important = (
    incendie_grave_jour_j or 
    accident_majeur_jour_j or 
    agression_grave_jour_j
)

if evenement_important:
    poids_randomite = 0.7  # 70% du score total
else:
    poids_randomite = 0.2  # 20% du score total

# Calcul score congestion avec pondération
score_randomite = randomite * poids_randomite
score_deterministe = (accidents + incendies + agressions + ...) * (1 - poids_randomite)
congestion[j] = score_randomite + score_deterministe
```

### Integration avec Story 2.2.3

La Story 2.2.3 (Golden Hour) devra **charger** cette table de congestion depuis `data/intermediate/run_XXX/generation/congestion.pkl` et l'utiliser pour calculer :
```python
temps_trajet_reel = temps_base × ∏(congestion_microzone_traversee)
```

### Testing Standards

- Tests unitaires : Validation calcul taux (plages raisonnables, cohérence avec accidents ↑)
- Tests effets temporels incendies : Vérifier que jour J → ↑, J+1 → ↓, J+2 → ↓
- Tests effets temporels agressions graves : Vérifier que jour J → ↑↑ (forte), J+1 → ↓, J+2 → ↓, J+3 → ↓
- Tests saisonnalité : Vérifier que congestion intersaison > hiver/été
- Tests pondération randomité : Vérifier que randomité = 0.2 normal, 0.7 événement important
- Tests de structure : Table correctement formatée (microzone_id, jour, taux_ralentissement)
- Tests d'intégration : Table disponible avant Golden Hour, chargement correct
- Tests historique : Vérifier que les effets temporels sont appliqués correctement aux jours suivants
- Framework : pytest
- Emplacement : `tests/core/generation/test_congestion_calculator.py`

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (via Cursor)

### Completion Notes
- ✅ Chargement congestion statique depuis `data/source_data/congestion_statique.pkl` avec gestion erreur (valeurs par défaut si absent)
- ✅ Structure de données : Dict[microzone_id, Dict[jour, float]] pour table congestion dynamique
- ✅ Calcul taux de ralentissement base avec pondération dynamique :
  - Randomité normale : 0.2 (20% du score total)
  - Randomité événement important : 0.7 (70% du score total)
- ✅ Détection événements importants : incendies graves, accidents majeurs, agressions graves
- ✅ Effet accidents : ↑ congestion (+5% par accident, cap +30%)
- ✅ Effets temporels incendies :
  - Jour J : ↑ congestion (×1.2)
  - Jours J+1 et J+2 : ↓ congestion (×0.8 - état de choc)
- ✅ Effets temporels agressions graves :
  - Jour J : ↑↑ congestion (×1.5 - augmentation forte)
  - Jours J+1, J+2, J+3 : ↓ congestion (×0.7)
- ✅ Suivi historique incidents : historique_incidents pour appliquer effets temporels jours suivants
- ✅ Récurrence microzone : effet persistant si congestion récente élevée (+5%)
- ✅ Influence voisins : propagation spatiale (+10% si voisins congestion élevée)
- ✅ Effets événements : +20% événements graves, -5% événements positifs
- ✅ Congestion nuit : divisée par 3 moyenne (avec aléatoire ±20%), 2.2 l'été, application uniquement incidents nocturnes
- ✅ Formule agrégation : `congestion_finale = (congestion_statique × facteurs_dynamiques × poids_deterministe + congestion_statique × randomité) × night_factor`
- ✅ Modification temps réel : `update_congestion_realtime()` pour événements graves
- ✅ Intégration boucle jour-à-jour : calcul après génération vecteurs dans `GenerationService.generate_day()`
- ✅ Sauvegarde table congestion : format pickle standardisé dans `data/intermediate/run_XXX/generation/congestion.pkl`
- ✅ Tests unitaires complets : calcul taux, effets temporels, saisonnalité, pondération randomité, congestion nuit, structure table

### File List
**Nouveaux fichiers créés :**
- `src/core/generation/congestion_calculator.py` - Calculateur de congestion dynamique
- `tests/core/generation/test_congestion_calculator.py` - Tests unitaires complets

**Fichiers modifiés :**
- `src/core/generation/generation_service.py` - Intégration calcul congestion après génération vecteurs

### Debug Log References
- Intégration avec GenerationService : calcul congestion automatique après génération vecteurs
- Mise à jour dynamic_state.trafic avec valeurs normalisées [0, 1]

### Status
Ready for Review

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 28 Jan 2026 | 1.0 | Création story | PM |
| 28 Jan 2026 | 1.1 | Ajout effets temporels : incendies (J↑/J+1↓/J+2↓) et agressions graves (J↑↑/J+1↓/J+2↓/J+3↓) | PM |
| 28 Jan 2026 | 1.2 | Ajout saisonnalité (intersaison > hiver/été) et pondération randomité (0.2 normal, 0.7 événement important) | PM |
| 28 Jan 2026 | 2.0 | Réorganisation : Utilisation congestion statique pré-calculée (Story 1.3) + modifications temps réel événements graves | PM |
| 28 Jan 2026 | 2.1 | Ajout congestion nuit (divisée par 3 moyenne, 2.2 l'été) | PM |
| 29 Jan 2026 | 2.2 | Implémentation complète - Calcul taux de ralentissement de trafic avec tous les effets | Dev (James) |
