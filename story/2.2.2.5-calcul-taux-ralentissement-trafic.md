# Story 2.2.2.5 : Pré-calcul taux de ralentissement de trafic par microzone et par jour

**Status:** Draft  
**Epic:** Epic 2 - Système de Simulation et Prédiction  
**Story Number:** 2.2.2.5

---

## Story

**As a** système de simulation,  
**I want** pré-calculer une table du taux de ralentissement de trafic pour chaque microzone et chaque jour,  
**so that** le calcul Golden Hour (Story 2.2.3) peut utiliser ces données de congestion pré-calculées pour déterminer les temps de trajet réels.

---

## Acceptance Criteria

1. **Table de congestion** : Création d'une structure de données (DataFrame ou dictionnaire) stockant le **taux de ralentissement** (facteur de congestion) pour chaque microzone et chaque jour de simulation.
2. **Calcul du taux de ralentissement** : Le taux est calculé à partir de :
   - **Randomness** (variabilité aléatoire de base) avec **pondération dynamique** :
     - **Normalement** : randomité = **0.2 sur 1** (20% du score total de congestion)
     - **Événement important** : randomité = **0.7 sur 1** (70% du score total - événements majeurs augmentent l'imprévisibilité)
   - **Saisonnalité** : Congestion plus forte en **intersaison** (printemps/automne) qu'en **hiver** et **été**
   - **Accidents** (↑ congestion : accidents augmentent le ralentissement)
   - **Incendies** (effets temporels) :
     - **Jour J** : ↑ congestion (augmentation ralentissement le jour de l'incendie)
     - **Jours J+1 et J+2** : ↓ congestion (diminution ralentissement - état de choc de la population, moins de circulation)
   - **Agressions graves** (effets temporels) :
     - **Jour J** : ↑↑ congestion (augmentation **forte** du ralentissement - diminution très forte de la circulation)
     - **Jours J+1, J+2, J+3** : ↓ congestion (diminution ralentissement - augmentation de la circulation)
   - **Récurrence microzone** : Historique de la microzone (effets persistants)
   - **Voisins** : Influence des microzones adjacentes (propagation spatiale)
   - **Événements** : Effets des événements graves/positifs sur la congestion
3. **Formule de calcul** : Le taux de ralentissement est un **facteur multiplicatif** (ex. 1.0 = normal, 1.5 = +50% temps, 0.8 = -20% temps) utilisé dans `temps_trajet_reel = temps_base × ∏(congestion_microzone_traversee)`.
4. **Sauvegarde** : Table sauvegardée en pickle dans `data/intermediate/run_XXX/generation/congestion.pkl` (ou structure équivalente par run).
5. **Intégration** : La table est **calculée jour-à-jour** en même temps que les vecteurs (Story 2.2.1) et **avant** le calcul Golden Hour (Story 2.2.3).
6. **Tests unitaires** : Validation calcul taux (plages raisonnables, cohérence avec accidents/incendies/agressions), validation effets temporels (incendies J/J+1/J+2, agressions graves J/J+1/J+2/J+3), validation saisonnalité (intersaison > hiver/été), validation pondération randomité (0.2 normal, 0.7 événement important), structure table, sauvegarde/chargement.

---

## Integration Verification

IV1: Table de congestion calculée correctement (facteurs cohérents avec accidents ↑, incendies avec effets temporels J↑/J+1↓/J+2↓, agressions graves avec effets temporels J↑↑/J+1↓/J+2↓/J+3↓, saisonnalité intersaison > hiver/été, pondération randomité 0.2/0.7).  
IV2: Table disponible et chargée avant Story 2.2.3 (Golden Hour).  
IV3: Performance : Calcul congestion n'impacte pas significativement le temps de génération jour-à-jour (≤ 0.33s/jour global).

---

## Tasks / Subtasks

- [ ] Définir structure de données pour table congestion (DataFrame ou dict)
- [ ] Implémenter calcul taux de ralentissement base (randomness) avec pondération dynamique :
  - [ ] Randomité normale : 0.2 sur 1 (20% du score total)
  - [ ] Randomité événement important : 0.7 sur 1 (70% du score total)
- [ ] Implémenter effet saisonnalité (intersaison > hiver/été)
- [ ] Implémenter détection événements importants (pour basculer randomité 0.2 → 0.7)
- [ ] Implémenter effet accidents sur congestion (↑)
- [ ] Implémenter effet incendies avec effets temporels :
  - [ ] Jour J : ↑ congestion (augmentation ralentissement)
  - [ ] Jours J+1 et J+2 : ↓ congestion (diminution - état de choc population)
- [ ] Implémenter effet agressions graves avec effets temporels :
  - [ ] Jour J : ↑↑ congestion (augmentation forte - diminution très forte circulation)
  - [ ] Jours J+1, J+2, J+3 : ↓ congestion (diminution - augmentation circulation)
- [ ] Implémenter suivi historique incidents (pour appliquer effets temporels jours suivants)
- [ ] Implémenter récurrence microzone (historique)
- [ ] Implémenter influence voisins (propagation spatiale)
- [ ] Implémenter effets événements (graves/positifs)
- [ ] Implémenter formule agrégation (facteur multiplicatif final)
- [ ] Intégrer calcul dans boucle jour-à-jour (avec Story 2.2.1)
- [ ] Implémenter sauvegarde table congestion (pickle)
- [ ] Tests : validation calcul taux (plages, cohérence)
- [ ] Tests : validation effets temporels (incendies J/J+1/J+2, agressions graves J/J+1/J+2/J+3)
- [ ] Tests : validation saisonnalité (intersaison > hiver/été)
- [ ] Tests : validation pondération randomité (0.2 normal, 0.7 événement important)
- [ ] Tests : structure table, sauvegarde/chargement

---

## Dev Notes

### Architecture Context

- **Congestion** : Taux de ralentissement de trafic par microzone et par jour (facteur multiplicatif)
- **Utilisation** : Utilisé dans Story 2.2.3 (Golden Hour) pour calculer `temps_trajet_reel = temps_base × ∏(congestion_microzone_traversee)`
- **Calcul** : Jour-à-jour, en même temps que les vecteurs (Story 2.2.1)
- **Facteurs d'influence** :
  - **Randomness** (variabilité aléatoire) avec **pondération dynamique** :
    - Normalement : **0.2 sur 1** (20% du score total)
    - Événement important : **0.7 sur 1** (70% du score total - événements majeurs augmentent l'imprévisibilité)
  - **Saisonnalité** : Congestion plus forte en **intersaison** (printemps/automne) qu'en **hiver** et **été**
  - Accidents (↑ congestion)
  - **Incendies** (effets temporels) :
    - Jour J : ↑ congestion (augmentation ralentissement)
    - Jours J+1 et J+2 : ↓ congestion (diminution - état de choc de la population, moins de circulation)
  - **Agressions graves** (effets temporels) :
    - Jour J : ↑↑ congestion (augmentation **forte** - diminution très forte de la circulation)
    - Jours J+1, J+2, J+3 : ↓ congestion (diminution - augmentation de la circulation)
  - Récurrence microzone (historique)
  - Voisins (propagation spatiale)
  - Événements (graves/positifs)
- **Suivi historique** : Nécessaire pour appliquer les effets temporels (incendies J+1/J+2, agressions graves J+1/J+2/J+3)
- **Ordre** : Calculé **avant** Story 2.2.3 (Golden Hour) mais **pendant** la génération jour-à-jour (Story 2.2.1)

### Source Tree

```
src/core/generation/
├── vector_generator.py
├── regime_manager.py
├── intensity_calculator.py
└── congestion_calculator.py  # Nouveau module pour cette story

data/intermediate/
└── run_XXX/
    └── generation/
        ├── vecteurs_base.pkl
        ├── vecteurs_proportions.pkl
        └── congestion.pkl  # Table taux de ralentissement
```

### Dependencies

- Vecteurs : Story 2.2.1 (pour connaître accidents/incendies)
- Événements : Story 2.2.7 (pour effets événements graves)
- Voisins : Données adjacents (en dur dans code)

### Implémentation des effets temporels

**Suivi historique nécessaire** : Pour appliquer les effets temporels aux jours suivants, il faut maintenir un historique des incidents par microzone :
- **Incendies** : Stocker les jours où des incendies (moyen/grave) ont eu lieu pour appliquer ↓ congestion aux jours J+1 et J+2
- **Agressions graves** : Stocker les jours où des agressions graves ont eu lieu pour appliquer ↓ congestion aux jours J+1, J+2 et J+3

**Exemple d'implémentation** :
```python
# Jour J : Incendie détecté
if incendie_moyen_grave_jour_j:
    congestion[j] *= 1.2  # ↑ congestion jour J
    historique_incendies[microzone].append(j)  # Enregistrer pour J+1 et J+2

# Jours suivants : Appliquer effets retardés
for jour_incendie in historique_incendies[microzone]:
    if j == jour_incendie + 1 or j == jour_incendie + 2:
        congestion[j] *= 0.8  # ↓ congestion (état de choc)
```

**Même logique pour agressions graves** avec fenêtre J+1, J+2, J+3.

### Implémentation saisonnalité et pondération randomité

**Saisonnalité** : La congestion est modulée selon la saison :
```python
# Déterminer saison à partir du jour de l'année
saison = determine_saison(jour_annee)

if saison in ['printemps', 'automne']:  # Intersaison
    facteur_saison = 1.2  # +20% congestion
elif saison in ['hiver', 'ete']:
    facteur_saison = 0.9  # -10% congestion
else:
    facteur_saison = 1.0  # Normal

congestion[j] *= facteur_saison
```

**Pondération randomité** : Le poids de la randomité dans le score total varie selon la présence d'événements importants :
```python
# Détecter événements importants (incendies graves, accidents majeurs, agressions graves)
evenement_important = (
    incendie_grave_jour_j or 
    accident_majeur_jour_j or 
    agression_grave_jour_j
)

if evenement_important:
    poids_randomite = 0.7  # 70% du score total
else:
    poids_randomite = 0.2  # 20% du score total

# Calcul score congestion avec pondération
score_randomite = randomite * poids_randomite
score_deterministe = (accidents + incendies + agressions + ...) * (1 - poids_randomite)
congestion[j] = score_randomite + score_deterministe
```

### Integration avec Story 2.2.3

La Story 2.2.3 (Golden Hour) devra **charger** cette table de congestion depuis `data/intermediate/run_XXX/generation/congestion.pkl` et l'utiliser pour calculer :
```python
temps_trajet_reel = temps_base × ∏(congestion_microzone_traversee)
```

### Testing Standards

- Tests unitaires : Validation calcul taux (plages raisonnables, cohérence avec accidents ↑)
- Tests effets temporels incendies : Vérifier que jour J → ↑, J+1 → ↓, J+2 → ↓
- Tests effets temporels agressions graves : Vérifier que jour J → ↑↑ (forte), J+1 → ↓, J+2 → ↓, J+3 → ↓
- Tests saisonnalité : Vérifier que congestion intersaison > hiver/été
- Tests pondération randomité : Vérifier que randomité = 0.2 normal, 0.7 événement important
- Tests de structure : Table correctement formatée (microzone_id, jour, taux_ralentissement)
- Tests d'intégration : Table disponible avant Golden Hour, chargement correct
- Tests historique : Vérifier que les effets temporels sont appliqués correctement aux jours suivants
- Framework : pytest
- Emplacement : `tests/core/generation/test_congestion_calculator.py`

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 28 Jan 2026 | 1.0 | Création story | PM |
| 28 Jan 2026 | 1.1 | Ajout effets temporels : incendies (J↑/J+1↓/J+2↓) et agressions graves (J↑↑/J+1↓/J+2↓/J+3↓) | PM |
| 28 Jan 2026 | 1.2 | Ajout saisonnalité (intersaison > hiver/été) et pondération randomité (0.2 normal, 0.7 événement important) | PM |
