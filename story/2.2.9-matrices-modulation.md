# Story 2.2.9 : Trois matrices de modulation (gravité, croisée, voisins)

**Status:** Draft  
**Epic:** Epic 2 - Système de Simulation et Prédiction  
**Story Number:** 2.2.9

---

## Story

**As a** système de simulation,  
**I want** appliquer trois matrices de modulation (gravité microzone, types croisés, voisins) dans calcul intensités,  
**so that** les corrélations spatiales et temporelles sont prises en compte dans prédiction J+1.

---

## Acceptance Criteria

1. Matrice gravité microzone: Même type, même microzone, historique 7 jours avec décroissance exponentielle
2. Matrice types croisés: Autres types, même microzone, corrélations spécifiques (ex: incendie→accidents ×1.3). **Effet nb total autres types** : Le nb total des 2 autres types d'incidents influence la génération (ex: nb total incendies + agressions → influence accidents). **Changement effet J+1** : Changement d'effet sur génération aléatoire dans J+1 selon historique J-1 (conformité à J-1, co-aléatoire).
3. Matrice voisins: 8 zones alentours (radius 1), pondération grave ×1.0, moyen ×0.5, bénin ×0.2, modulée par variabilité locale
4. **Modulations dynamiques** : Les trois matrices de modulation sont **modulées en temps réel** par :
   - **Événements** : Modifications par événements graves/positifs
   - **Incidents** : Modifications par incidents (accidents, incendies, agressions)
   - **Régimes** : Modifications par régimes cachés (Stable/Détérioration/Crise)
   - **Patterns** : Modifications par patterns (4j, 7j, 60j)
5. Intégration dans formule: `λ_calibrated(τ,g) = λ_base(τ,g) × facteur_statique × facteur_gravité × facteur_croisé × facteur_voisins × facteur_long` où tous les facteurs sont modulés dynamiquement.
6. Normalisation: `Z(t) = Σ_{τ,g} λ_calibrated(τ,g)`
7. Caps: Min ×0.1, Max ×3.0
8. Tests unitaires validant calculs matrices, modulations dynamiques, intégration formule, normalisation, caps

---

## Integration Verification

IV1: Vérifier que les trois matrices sont calculées correctement (historique, corrélations, voisins)  
IV2: Vérifier que l'intégration dans formule intensités calibrées fonctionne (pas d'erreurs, valeurs cohérentes)  
IV3: Vérifier que la normalisation et les caps sont appliqués correctement

---

## Tasks / Subtasks

- [x] Implémenter matrice gravité microzone (même type, même microzone, historique 7 jours, décroissance exponentielle)
- [x] Implémenter matrice types croisés (autres types, même microzone, corrélations spécifiques)
- [x] Implémenter effet nb total des 2 autres types d'incidents sur génération
- [x] Implémenter changement d'effet sur génération aléatoire J+1 selon historique J-1 (conformité J-1)
- [x] Implémenter matrice voisins (8 zones radius 1, pondération grave×1.0, moyen×0.5, bénin×0.2, variabilité locale)
- [x] Implémenter modulations dynamiques par événements (graves/positifs)
- [x] Implémenter modulations dynamiques par incidents (intégré dans modulations événements)
- [x] Implémenter modulations dynamiques par régimes
- [x] Implémenter modulations dynamiques par patterns
- [x] Implémenter intégration dans formule intensités calibrées (avec modulations dynamiques)
- [x] Implémenter normalisation (`Z(t) = Σ_{τ,g} λ_calibrated(τ,g)`)
- [x] Implémenter caps (Min ×0.1, Max ×3.0)
- [x] Tests : calculs matrices, intégration formule, normalisation, caps

---

## Dev Notes

### Architecture Context

- **Trois matrices de modulation** : Gravité microzone, types croisés, voisins (FR16)
- **Matrice gravité** : Même type, même microzone, historique 7 jours, décroissance exponentielle
- **Matrice types croisés** : Autres types, même microzone, corrélations (ex: incendie→accidents ×1.3)
- **Effet nb total autres types** : Le nb total des 2 autres types d'incidents influence la génération
- **Changement effet J+1** : Changement d'effet sur génération aléatoire J+1 selon historique J-1 (conformité J-1, co-aléatoire)
- **Matrice voisins** : 8 zones radius 1, pondération grave×1.0, moyen×0.5, bénin×0.2, variabilité locale
- **Intégration formule** : `λ_calibrated = λ_base × facteur_statique × facteur_gravité × facteur_croisé × facteur_voisins × facteur_long`
- **Normalisation** : `Z(t) = Σ_{τ,g} λ_calibrated(τ,g)`
- **Caps** : Min ×0.1, Max ×3.0

### Source Tree

```
src/core/generation/
└── intensity_calculator.py  # Calcul intensités calibrées avec matrices

src/core/state/
└── simulation_state.py      # Historique pour matrice gravité
```

### Dependencies

- Vecteurs : Story 2.2.1 (historique pour matrice gravité)
- Voisins : Données adjacents (en dur dans code)
- Patterns : Story 2.2.2 (facteur_long, modulations)
- Événements : Story 2.2.7, 2.2.8 (modulations dynamiques)
- Régimes : Story 2.2.1 (modulations dynamiques)

### Formule intensités calibrées

```python
# Calcul facteurs
facteur_gravite = calcul_matrice_gravite(microzone, type, historique_7j)
facteur_croise = calcul_matrice_croisee(microzone, type, autres_types)
facteur_voisins = calcul_matrice_voisins(microzone, voisins, variabilite)

# Intensité calibrée
lambda_calibrated = (
    lambda_base *
    facteur_statique *
    facteur_gravite *
    facteur_croise *
    facteur_voisins *
    facteur_long
)

# Normalisation
Z = sum(lambda_calibrated pour tous types et gravités)

# Caps
lambda_calibrated = max(0.1 * lambda_base, min(3.0 * lambda_base, lambda_calibrated))
```

### Testing Standards

- Tests unitaires : Calculs matrices, intégration formule, normalisation, caps
- Tests de validation : Valeurs cohérentes, pas d'erreurs
- Framework : pytest
- Emplacement : `tests/core/generation/test_intensity_calculator.py`

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (via Cursor)

### Completion Notes
- ✅ MatrixModulator : Classe complète pour calculer les trois matrices de modulation
- ✅ Matrice gravité microzone : Historique 7 jours avec décroissance exponentielle (DECAY_FACTOR = 0.85)
- ✅ Matrice types croisés : Effet nb total des 2 autres types + conformité J-1
- ✅ Matrice voisins : Pondération grave×1.0, moyen×0.5, bénin×0.2, modulation variabilité locale
- ✅ Modulations dynamiques : Événements graves/positifs, régimes (Stable/Détérioration/Crise), patterns (4j, 7j, 60j)
- ✅ Formule complète : `λ_calibrated = λ_base × facteur_statique × facteur_gravité × facteur_croisé × facteur_voisins × facteur_long`
- ✅ Normalisation : `Z(t) = Σ_{τ,g} λ_calibrated(τ,g)`
- ✅ Caps : Min ×0.1, Max ×3.0 appliqués dans `calculer_intensite_calibree()`
- ✅ Intégration IntensityCalculator : Utilise MatrixModulator si disponible, sinon méthode simplifiée (rétrocompatibilité)
- ✅ Intégration VectorGenerator : Passage paramètres pour MatrixModulator (vectors_state, events, variabilite_locale)
- ✅ Intégration GenerationService : Création MatrixModulator et passage événements/vecteurs_state
- ✅ Tests unitaires complets : MatrixModulator, facteurs, modulations dynamiques, caps, normalisation

### File List
**Nouveaux fichiers créés :**
- `src/core/generation/matrix_modulator.py` - MatrixModulator pour calcul matrices de modulation
- `tests/core/generation/test_matrix_modulator.py` - Tests MatrixModulator
- `story/2.2.9-ANALYSE-DONNEES-EXISTANTES.md` - Analyse des données existantes

**Fichiers modifiés :**
- `src/core/generation/intensity_calculator.py` - Intégration MatrixModulator avec rétrocompatibilité
- `src/core/generation/vector_generator.py` - Passage paramètres pour MatrixModulator
- `src/core/generation/generation_service.py` - Création MatrixModulator et intégration

### Debug Log References
- Matrice gravité : Historique 7 jours (J-6 à J-1) avec décroissance exponentielle (poids = DECAY_FACTOR^(offset-1))
- Matrice types croisés : Effet nb total autres types + conformité J-1 (facteur_conformite = 1.0 + total_j_minus_1 * 0.1)
- Matrice voisins : Pondération POIDS_VOISIN = (0.2, 0.5, 1.0) pour (bénin, moyen, grave)
- Modulations dynamiques : facteur_long = facteur_events × facteur_regime × facteur_patterns
- Caps : `max(MIN_FACTOR * lambda_base, min(MAX_FACTOR * lambda_base, lambda_calibrated))`

### Status
Ready for Review

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 28 Jan 2026 | 1.0 | Création story | PM |
| 28 Jan 2026 | 1.1 | Ajout effet nb total autres types et changement effet J+1 selon J-1 | PM |
| 29 Jan 2026 | 1.2 | Implémentation complète - Trois matrices de modulation avec modulations dynamiques | Dev (James) |
