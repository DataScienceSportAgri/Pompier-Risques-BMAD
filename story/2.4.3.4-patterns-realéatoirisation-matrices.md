# Story 2.4.3.4 : Patterns de réaléatoirisation (réduction aléatoire de l’effet des matrices de corrélation)

**Status:** Draft  
**Epic:** Epic 2 - Système de Simulation et Prédiction  
**Story Number:** 2.4.3.4

---

## Story

**As a** système de simulation,  
**I want** générer aléatoirement des patterns de « réaléatoirisation » **spécifiques à un arrondissement**, qui réduisent de 60 % à 85 % l’effet de toutes les matrices de corrélation dans le processus de génération J→J+1 pour les microzones de cet arrondissement, avec un déclenchement en moyenne tous les 7 à 12 jours et une durée de 15 à 20 jours par pattern, **au plus 4 patterns actifs simultanément par arrondissement**, et des rampes d’intensité de 2 à 4 jours en début, en milieu, et en fin de pattern,  
**so that** la simulation évite les effets de verrouillage (cascades, microzones toujours vides ou surchargées) tout en conservant une structure temporelle crédible et une granularité spatiale par arrondissement.

---

## Contexte

- **Matrices de corrélation** (Story 2.2.9, 1.4.4) : dans le flux J→J+1, les matrices de modulation (gravité microzone, types croisés, voisins) et les matrices utilisées pour l’évolution des variables d’état (trafic, nuit, alcool) amplifient les corrélations. En l’absence de mécanisme de « découplage », des effets de surenchère ou de microzones systématiquement vides peuvent persister (Story 2.4.3.2).
- **Objectif** : introduire des **fenêtres de réaléatoirisation** générées aléatoirement, **spécifiques à un arrondissement** (l’effet ne s’applique qu’aux microzones de cet arrondissement), pendant lesquelles l’effet de **toutes** ces matrices est fortement réduit (60–85 % de réduction, soit 15–40 % de l’effet conservé). Ces fenêtres se déclenchent en moyenne tous les 15–20 jours, durent 15–20 jours, avec **au plus 2 patterns actifs simultanément par arrondissement**, et des **rampes** en début et en fin (2–4 jours) où l’intensité varie (montée en début, descente en fin).

---

## Acceptance Criteria

### A. Génération et déclenchement des patterns (par arrondissement)

1. **Spécificité arrondissement** : Chaque pattern de réaléatoirisation est **affecté à un arrondissement** (1–20). La réduction de l’effet des matrices ne s’applique qu’aux **microzones de cet arrondissement** lors du calcul J→J+1.
2. **Déclenchement** : Pour chaque arrondissement, un nouveau pattern est déclenché **aléatoirement**, avec une **période moyenne** entre deux déclenchements de **15 à 20 jours** (paramétrable, ex. loi géométrique ou exponentielle discrète). Le premier pattern par arrondissement peut être tiré après un délai initial (éventuellement différent par arrondissement).
3. **Durée d’un pattern** : Chaque pattern a une **durée totale** tirée aléatoirement dans l’intervalle **15–20 jours** (bornes paramétrables).
4. **Maximum 2 patterns simultanés par arrondissement** : Pour un même arrondissement, **au plus 2 patterns** peuvent être actifs en même temps. Si un nouveau déclenchement survient alors que 2 patterns sont déjà actifs pour cet arrondissement, le nouveau pattern est **reporté** à la fin du premier pattern qui se termine. Si 1 seul pattern est actif, un deuxième peut démarrer (chevauchement autorisé jusqu’à 2).

### B. Intensité de réaléatoirisation et rampes

5. **Réduction de l’effet des matrices** : Pendant un pattern (au plateau), **toutes** les matrices de corrélation impliquées dans J→J+1 voient leur effet réduit de **60 % à 85 %** pour les microzones de l’arrondissement concerné (équivalent : on n’applique que **15 % à 40 %** de l’effet). Les matrices concernées incluent au minimum : gravité, types croisés, voisins (Story 2.2.9), et si applicable les matrices d’évolution trafic / nuit / alcool (Story 1.4.4).
6. **Rampe en début de pattern** : Les **2 à 4 premiers jours** du pattern forment une **rampe de montée** : l’intensité de réaléatoirisation (réduction) passe progressivement de 0 % à la valeur du plateau (60–85 %). La durée de la rampe est tirée dans [2, 4] jours (paramétrable).
7. **Rampe en fin de pattern** : Les **2 à 4 derniers jours** du pattern forment une **rampe de descente** : l’intensité redescend progressivement de la valeur du plateau à 0 %. La durée de la rampe est tirée dans [2, 4] jours (paramétrable).
8. **Plateau** : Entre les deux rampes, les jours restants sont au **plateau** (réduction constante, même niveau 60–85 %). La durée totale du pattern (15–20 jours) inclut rampe début + plateau + rampe fin.

### C. Application dans le pipeline J→J+1 (par microzone / arrondissement)

9. **Facteur par microzone** : À chaque jour J et pour chaque microzone, un **facteur de réaléatoirisation** \( \alpha(J, \text{microzone}) \in [0, 1] \) est calculé à partir des pattern(s) actifs **pour l’arrondissement de cette microzone** (0 = pas de réaléatoirisation, 1 = réduction maximale). L’effet des matrices pour cette microzone est multiplié par \( (1 - r \cdot \alpha) \) où \( r \in [0.60, 0.85] \) est le taux au plateau du pattern concerné. **Combinaison de 2 patterns actifs** : si deux patterns se chevauchent pour le même arrondissement, on combine leurs contributions (ex. \( \alpha_{\text{eff}} = \min(1, \alpha_1 + \alpha_2) \) ou prendre le max ; à définir en implémentation et documenter).
10. **Cohérence** : Le facteur \( \alpha(J, \text{microzone}) \) s’applique à **toutes** les matrices du processus J→J+1 pour cette microzone (gravité, croisée, voisins, et évolution trafic/nuit/alcool si intégré). Les microzones d’un arrondissement sans pattern actif ont \( \alpha = 0 \).

### D. État et reproductibilité

11. **État de simulation** : Les patterns de réaléatoirisation (arrondissement, dates de début, durée, rampes, taux \( r \)) sont **déterminés à l’avance** ou **enregistrés** dans l’état de simulation (ex. `SimulationState` ou structure dédiée) pour que la simulation soit **reproductible** avec un seed fixe.
12. **Paramètres en config** : Les bornes (15–20 jours entre déclenchements, 15–20 jours de durée, 2–4 jours de rampe, 60–85 % de réduction, **max 2 patterns simultanés par arrondissement**) sont **configurables** (fichier config ou constantes documentées).

### E. Tests et non-régression

13. **Test reproductible** : Un test (ou script) avec **seed fixe** vérifie qu’au moins un pattern de réaléatoirisation est déclenché pour au moins un arrondissement sur une simulation d’au moins 60 jours, que les rampes et le plateau sont bien appliqués, que le facteur \( \alpha \) n’affecte que les microzones de l’arrondissement concerné, et qu’aucun arrondissement n’a plus de 2 patterns actifs simultanément.
14. **Non-régression** : Les critères d’équité spatiale (Story 2.4.3.2) restent satisfaits sur 200 jours avec les patterns de réaléatoirisation activés (toutes microzones avec ≥ 1 jour avec incident et ≥ 10 jours vides).

---

## Integration Verification

IV1: Sur une simulation de 60+ jours avec seed fixe, au moins un pattern de réaléatoirisation est déclenché pour au moins un arrondissement ; les dates, durées et arrondissements sont reproductibles.  
IV2: Pendant le plateau d’un pattern, l’effet des matrices (gravité, croisée, voisins) est réduit conformément au taux (60–85 %) **uniquement pour les microzones de l’arrondissement concerné** ; pendant les rampes, la réduction varie progressivement.  
IV3: Par arrondissement, au plus 2 patterns sont actifs simultanément ; un troisième déclenchement est reporté à la fin du premier pattern qui se termine.  
IV4: Les paramètres (période, durée, rampes, taux, max 2 patterns par arrondissement) sont configurables ; la simulation reste reproductible avec le même seed.  
IV5: Le test d’équité spatiale (Story 2.4.3.2) sur 200 jours reste vert avec réaléatoirisation activée.

---

## Tasks / Subtasks

- [x] Définir la structure de données pour un « pattern de réaléatoirisation » : **arrondissement**, jour_debut, durée_totale, durée_rampe_debut, durée_rampe_fin, taux_reduction_r, et éventuellement liste des α(J) précalculés.
- [x] Implémenter le générateur de patterns **par arrondissement** : tirage de la période entre déclenchements (moyenne 15–20 j), durée du pattern (15–20 j), durées des rampes (2–4 j), taux r (60–85 %), avec **au plus 2 patterns actifs simultanément par arrondissement** (report si 2 déjà actifs).
- [x] Exposer le facteur α(J, microzone) (et r) dans le pipeline J→J+1 : pour chaque microzone, dériver l’arrondissement (mapping existant), puis calculer α à partir des pattern(s) actifs pour cet arrondissement ; en cas de 2 patterns actifs, combiner (ex. α_eff = min(1, α₁ + α₂) ou max(α₁, α₂) — documenter le choix).
- [x] Dans le calcul des intensités / évolution : appliquer le facteur (1 - r·α) **par microzone** à tous les effets des matrices (gravité, croisée, voisins ; et trafic/nuit/alcool si dans le périmètre) pour les microzones concernées.
- [x] Intégrer les paramètres (période, durée, rampes, taux min/max, **max_patterns_simultanes_par_arrondissement = 2**) dans la config (YAML ou constantes) et les documenter.
- [x] Ajouter un test reproductible (seed fixe) : 60+ jours, au moins un pattern pour au moins un arrondissement, vérification des rampes, du plateau, et qu’aucun arrondissement n’a plus de 2 patterns actifs.
- [ ] Exécuter le test d’équité spatiale (Story 2.4.3.2) sur 200 jours avec réaléatoirisation activée et confirmer qu’il reste vert.

---

## Dev Notes

### Architecture Context

- **Flux J→J+1** : Voir `docs/architecture/matrices-correlation-system.md` et Story 2.2.9. Les matrices de modulation (gravité, croisée, voisins) sont utilisées dans `MatrixModulator` / `IntensityCalculator` ; les évolutions trafic/nuit/alcool utilisent leurs propres matrices (Story 1.4.4).
- **Formule** : Pour chaque facteur matriciel \( F \in [F_{gravité}, F_{croisé}, F_{voisins}, \dots] \), en jour J on applique  
  \( F' = 1 + (F - 1) \cdot (1 - r \cdot \alpha(J)) \)  
  pour conserver un facteur 1 (neutre) quand α=1 (tout l’effet est annulé). Alternative plus simple : multiplier chaque facteur par \( (1 - r \cdot \alpha(J)) \) et renormaliser si nécessaire (détail à trancher en implémentation).
- **État** : Stocker soit la liste des patterns précalculés pour la run (**arrondissement**, début, durée, rampes, r), soit un générateur déterministe (seed) qui recalcule les mêmes patterns ; prévoir un champ dans `SimulationState` ou un module dédié (ex. `RealéatoirisationState` / `realéatoirisation_state.py`).
- **Mapping microzone → arrondissement** : Réutiliser la convention existante (ex. `microzone_id` de type `MZ_XX_YY` → arrondissement `XX`) comme dans Story 2.4.3.3.
- **Combinaison de 2 patterns actifs pour le même arrondissement** : Si deux patterns se chevauchent, définir une règle explicite (ex. α_eff = min(1, α₁ + α₂) ou max(α₁, α₂) ; documenter le choix en implémentation).

### Paramètres proposés (config)

| Paramètre | Borne / valeur | Description |
|-----------|----------------|-------------|
| `periode_moyenne_jours` | [15, 20] | Moyenne du nombre de jours entre deux déclenchements **par arrondissement** |
| `duree_pattern_jours` | [15, 20] | Durée totale d’un pattern (rampe début + plateau + rampe fin) |
| `duree_rampe_jours` | [2, 4] | Durée de la rampe en début et en fin de pattern |
| `taux_reduction_min` | 0.60 | Réduction minimale au plateau (60 %) |
| `taux_reduction_max` | 0.85 | Réduction maximale au plateau (85 %) |
| `max_patterns_simultanes_par_arrondissement` | 2 | Nombre maximum de patterns actifs en même temps pour un même arrondissement |

### Rampe d'intensité

- Jour 0 du pattern : α = 0 (pas de réduction).
- Jours 1 à `duree_rampe_debut` : α augmente linéairement de 0 à 1.
- Jours `duree_rampe_debut` à `duree_totale - duree_rampe_fin` : α = 1 (plateau).
- Derniers `duree_rampe_fin` jours : α diminue linéairement de 1 à 0.

### Source Tree (à adapter)

```
src/core/
├── generation/
│   ├── intensity_calculator.py   # Appliquer (1 - r·α) par microzone (α selon arrondissement)
│   ├── matrix_modulator.py       # Ou passer α(microzone) ici
│   └── ...
├── evolution/
│   ├── trafic_evolution.py       # Idem si dans périmètre
│   ├── nuit_evolution.py
│   ├── alcool_evolution.py
│   └── ...
└── state/
    ├── simulation_state.py       # Référence au state réaléatoirisation si besoin
    └── realéatoirisation_state.py  # (nouveau) Patterns par arrondissement, α(J, microzone)
```

Mapping microzone → arrondissement : réutiliser la logique de Story 2.4.3.3 (ex. `microzone_to_arrondissement`).

### Dependencies

- Story 2.2.9 (matrices de modulation)
- Story 2.4.3.2 (équité spatiale, non-régression)
- Story 2.4.3.3 (mapping microzone → arrondissement pour compteurs / tooltips)
- Story 1.4.4 (matrices de corrélation et variables d’état)
- Story 2.1.2 (SimulationState)

---

## Dev Agent Record

_(À compléter lors de l’implémentation.)_

---

## Change Log

| Date       | Version | Description                    | Author |
|------------|---------|--------------------------------|--------|
| 31 Jan 2026| 1.0     | Création story (après 2.4.3.3) | PM     |
| 31 Jan 2026| 1.1     | Patterns spécifiques à un arrondissement ; max 2 patterns actifs simultanément par arrondissement | PM     |
| 31 Jan 2026| 1.2     | Implémentation : patterns, MatrixModulator dampening, config, tests | Dev    |
